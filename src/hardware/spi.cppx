#include <cstring>

#include "hardware/uart.h"

/**
 * @brief Construct a SPI peripheral.
 *
 * @param port Which SPI peripheral to communicate with. Refer
 * to ST documentation for which SPI can be used on which pins.
 * @param baud Baud rate.  Most of the time, you will want 9600
 * or 115200.
 * @param 
 * @param 
 * @param 
 */

SPI::SPI(SPI::Port, uint32_t baud, GPIO::Port gpio, uint8_t miso, uint8_t mosi, 
        unit8_t slck, unit8_t nss, uint32_t mode, unit32_t direction, unit32_t nss_mode):
        port(port),regs(SpiPortregs[port]),baud(baud),
        miso(), mosi(), slck(), nss(), mode(), direction(), nss_mode(){
            spi[ports] = this;
    }

/**
 * @brief Initialize a SPI.  This handles initializing the necessary
 * GPIOs and installing interrupt handlers, too.
 */

void SPI::init(){

    handle.Instance = regs;
    handle.Init = {baud,
                   UART_WORDLENGTH_8B,
                   UART_STOPBITS_1,
                   UART_PARITY_NONE,
                   UART_MODE_TX_RX,
                   UART_HWCONTROL_NONE,
                   UART_OVERSAMPLING_16,
                   UART_ONEBIT_SAMPLING_DISABLED,
                   UART_PRESCALER_DIV1,
                   UART_FIFOMODE_DISABLE,
                   UART_TXFIFO_THRESHOLD_1_8,
                   UART_RXFIFO_THRESHOLD_1_8};
    handle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;

    miso.init();
    mosi.init();
    slck.init();
    nss.init();

    // initialize the clock and interrupt
    en_funcs[port]();
    HAL_NVIC_SetPriority(irqns[port], 14, 15);
    HAL_NVIC_EnableIRQ(irqns[port]);

    HAL_SPI_Init(&handle);

    SPI_handles[port] = &handle;
}

/**
 * @brief De-initialize a UART, and power off its dependencies, too
 * (GPIOs and interrupt handler).
 */
void SPI::deinit() {
    HAL_SPI_DeInit(&handle);
    dis_funcs[port]();
    HAL_NVIC_DisableIRQ(irqns[port]);

    miso.deinit();
    mosi.deinit();
    slck.deinit();
    nss.deinit();
}

/**
 * @brief Transmit a message over the UART (byte array).
 *
 * @param data Pointer to the start of the byte array.
 * @param len Its length.
 *
 * @return A promise that can be blocked on to retrieve the status of
 * the transmission.
 */
Async<SPI::SendStatus> SPI::transmit(const uint8_t *data, size_t len) {
    HAL_SPI_Transmit_IT(&handle, data, len);
    return sender.promise();
}

/**
 * @brief Transmit a C string over the UART.
 *
 * This is just a helper function specifically for null-terminated
 * strings.  Do NOT use this to send binary data; it will be mangled.
 *
 * @param msg The C string to be transmitted.
 *
 * @return A promise with the transmission status.
 */
Async<SPI::SendStatus> SPI::transmit(const char *msg) {
    size_t len = strlen(msg);
    const uint8_t *data = reinterpret_cast<const uint8_t *>(msg);
    
    return transmit(data, len);
}

SPI *SPI::spis[8];           //< Pointers to any SPIs in use, so
                                //  interrupt handlers can access them.
SPI_HandleTypeDef *SPI::spi_handles[8]; //< The interrupt callbacks
                                           //  demand we give them HAL
                                           //  handles.

/**
 * The interrupt number for each SPI.  We need these to know which to
 * enable/disable upon initialization.
 */
const IRQn_Type SPI::irqns[6] = {
    SPI1_IRQn, SPI2_IRQn, SPI3_IRQn, SPI4_IRQn,
    SPI5_IRQn,  SPI6_IRQn,
};

/**
 * Port number to port registers lookup table.  (The HAL wants a register block.)
 */
USART_TypeDef *const SPI::portregs[] = {
    SPI1, SPI2, SPI3, SPI4, SPI5, SPI6,
};